<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tiny STL: tstl::vector&lt; T, Allocator &gt; 模板类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tiny STL
   </div>
   <div id="projectbrief">A Tiny C++14 STL.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'搜索','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetstl.html">tstl</a></li><li class="navelem"><a class="el" href="clasststl_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pro-methods">Protected 成员函数</a> &#124;
<a href="#pro-attribs">Protected 属性</a> &#124;
<a href="#pri-types">Private 类型</a> &#124;
<a href="#friends">友元</a> &#124;
<a href="clasststl_1_1vector-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">tstl::vector&lt; T, Allocator &gt; 模板类 参考</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="vector_8hpp_source.html">vector.hpp</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:aa01279e0dee0bbf9d275b336625b1205"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> = T</td></tr>
<tr class="separator:aa01279e0dee0bbf9d275b336625b1205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add935423202d90f30acd218e7bc8ea53"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#add935423202d90f30acd218e7bc8ea53">allocator_type</a> = Allocator</td></tr>
<tr class="separator:add935423202d90f30acd218e7bc8ea53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed80c6c1ade9ac7baca57a633effd1c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> = std::size_t</td></tr>
<tr class="separator:abed80c6c1ade9ac7baca57a633effd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4523b0c1d86d385aeafbbbc2ae4a39d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#ac4523b0c1d86d385aeafbbbc2ae4a39d">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="separator:ac4523b0c1d86d385aeafbbbc2ae4a39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b239647222218d41379b3411ebe669"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a22b239647222218d41379b3411ebe669">reference</a> = <a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> &amp;</td></tr>
<tr class="separator:a22b239647222218d41379b3411ebe669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569b30003ae874f7cfa0aa87491c8e33"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a569b30003ae874f7cfa0aa87491c8e33">const_reference</a> = const <a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> &amp;</td></tr>
<tr class="separator:a569b30003ae874f7cfa0aa87491c8e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b425422d70c1926bffddbff35291402"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> = typename alloc_traits::pointer</td></tr>
<tr class="separator:a2b425422d70c1926bffddbff35291402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7263ad3876f0df996ee585e1b6460499"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a7263ad3876f0df996ee585e1b6460499">const_pointer</a> = typename alloc_traits::const_pointer</td></tr>
<tr class="separator:a7263ad3876f0df996ee585e1b6460499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2099f0a30068ff2976dfa9ab63a683f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> = tstl::_normal_iterator&lt; T *, <a class="el" href="clasststl_1_1vector.html">vector</a> &gt;</td></tr>
<tr class="separator:a2099f0a30068ff2976dfa9ab63a683f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6df383347f89966f8361ccd94fa4dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> = tstl::_normal_iterator&lt; const T *, <a class="el" href="clasststl_1_1vector.html">vector</a> &gt;</td></tr>
<tr class="separator:a8b6df383347f89966f8361ccd94fa4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287887267f1d559fdec764f0027deb3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a287887267f1d559fdec764f0027deb3a">reverse_iterator</a> = tstl::reverse_iterator&lt; <a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> &gt;</td></tr>
<tr class="separator:a287887267f1d559fdec764f0027deb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea949cba6e24f77f55b2cf2861fe4602"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#aea949cba6e24f77f55b2cf2861fe4602">const_reverse_iterator</a> = tstl::reverse_iterator&lt; <a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> &gt;</td></tr>
<tr class="separator:aea949cba6e24f77f55b2cf2861fe4602"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:aceefe3284d5d7bb394cef4b2435a25d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#aceefe3284d5d7bb394cef4b2435a25d3">vector</a> ()=default</td></tr>
<tr class="memdesc:aceefe3284d5d7bb394cef4b2435a25d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">默认构造函数。构造拥有默认构造的分配器的空容器。  <a href="clasststl_1_1vector.html#aceefe3284d5d7bb394cef4b2435a25d3">更多...</a><br /></td></tr>
<tr class="separator:aceefe3284d5d7bb394cef4b2435a25d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf966113ef059db92132e9d4c02ba5dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#abf966113ef059db92132e9d4c02ba5dd">vector</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:abf966113ef059db92132e9d4c02ba5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造拥有给定分配器 alloc 的空容器。  <a href="clasststl_1_1vector.html#abf966113ef059db92132e9d4c02ba5dd">更多...</a><br /></td></tr>
<tr class="separator:abf966113ef059db92132e9d4c02ba5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb39f1e6ee28c59e637c02e625f85ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a0fb39f1e6ee28c59e637c02e625f85ff">vector</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> count, const T &amp;value, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a0fb39f1e6ee28c59e637c02e625f85ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造拥有 count 个有值 value 的元素的容器。  <a href="clasststl_1_1vector.html#a0fb39f1e6ee28c59e637c02e625f85ff">更多...</a><br /></td></tr>
<tr class="separator:a0fb39f1e6ee28c59e637c02e625f85ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf187d4860e74f9b7121118148cce26e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#adf187d4860e74f9b7121118148cce26e">vector</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> count, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:adf187d4860e74f9b7121118148cce26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造拥有个 count 默认插入的 T 实例的容器。不进行复制。  <a href="clasststl_1_1vector.html#adf187d4860e74f9b7121118148cce26e">更多...</a><br /></td></tr>
<tr class="separator:adf187d4860e74f9b7121118148cce26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e19af70d985afe3d644f1494ebf2bec"><td class="memTemplParams" colspan="2">template&lt;class InputIt , typename  = tstl::_RequireInputIter&lt;InputIt&gt;&gt; </td></tr>
<tr class="memitem:a2e19af70d985afe3d644f1494ebf2bec"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a2e19af70d985afe3d644f1494ebf2bec">vector</a> (InputIt first, InputIt last, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a2e19af70d985afe3d644f1494ebf2bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造拥有范围 [first, last) 内容的容器。  <a href="clasststl_1_1vector.html#a2e19af70d985afe3d644f1494ebf2bec">更多...</a><br /></td></tr>
<tr class="separator:a2e19af70d985afe3d644f1494ebf2bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4342d411a6e05bfa4ccb6cd9667ca28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#ac4342d411a6e05bfa4ccb6cd9667ca28">vector</a> (const <a class="el" href="clasststl_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:ac4342d411a6e05bfa4ccb6cd9667ca28"><td class="mdescLeft">&#160;</td><td class="mdescRight">复制构造函数。构造拥有 other 内容的容器。  <a href="clasststl_1_1vector.html#ac4342d411a6e05bfa4ccb6cd9667ca28">更多...</a><br /></td></tr>
<tr class="separator:ac4342d411a6e05bfa4ccb6cd9667ca28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615a002ad955dc4ec65b4e8763b5ccad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a615a002ad955dc4ec65b4e8763b5ccad">vector</a> (const <a class="el" href="clasststl_1_1vector.html">vector</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a615a002ad955dc4ec65b4e8763b5ccad"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造拥有 other 内容的容器，以 alloc 为分配器。  <a href="clasststl_1_1vector.html#a615a002ad955dc4ec65b4e8763b5ccad">更多...</a><br /></td></tr>
<tr class="separator:a615a002ad955dc4ec65b4e8763b5ccad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9321300dc4e736ad809e7014449a93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a8f9321300dc4e736ad809e7014449a93">vector</a> (<a class="el" href="clasststl_1_1vector.html">vector</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a8f9321300dc4e736ad809e7014449a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">移动构造函数。  <a href="clasststl_1_1vector.html#a8f9321300dc4e736ad809e7014449a93">更多...</a><br /></td></tr>
<tr class="separator:a8f9321300dc4e736ad809e7014449a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ceb74e1354bf68cef3f2ac4aea04b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a10ceb74e1354bf68cef3f2ac4aea04b5">vector</a> (<a class="el" href="clasststl_1_1vector.html">vector</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a10ceb74e1354bf68cef3f2ac4aea04b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">有分配器扩展的移动构造函数。  <a href="clasststl_1_1vector.html#a10ceb74e1354bf68cef3f2ac4aea04b5">更多...</a><br /></td></tr>
<tr class="separator:a10ceb74e1354bf68cef3f2ac4aea04b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0d0d4d29322e2cd8e86df01a366366"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#aea0d0d4d29322e2cd8e86df01a366366">vector</a> (std::initializer_list&lt; T &gt; init, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:aea0d0d4d29322e2cd8e86df01a366366"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造拥有 initializer_list 内容的容器。  <a href="clasststl_1_1vector.html#aea0d0d4d29322e2cd8e86df01a366366">更多...</a><br /></td></tr>
<tr class="separator:aea0d0d4d29322e2cd8e86df01a366366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7c4744b067c70e2ea50989e7da6822"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a4d7c4744b067c70e2ea50989e7da6822">~vector</a> ()</td></tr>
<tr class="memdesc:a4d7c4744b067c70e2ea50989e7da6822"><td class="mdescLeft">&#160;</td><td class="mdescRight">销毁 vector。  <a href="clasststl_1_1vector.html#a4d7c4744b067c70e2ea50989e7da6822">更多...</a><br /></td></tr>
<tr class="separator:a4d7c4744b067c70e2ea50989e7da6822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214ecc697d517f1b0d2d64e03e797fde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a214ecc697d517f1b0d2d64e03e797fde">operator=</a> (const <a class="el" href="clasststl_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:a214ecc697d517f1b0d2d64e03e797fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">复制赋值运算符。  <a href="clasststl_1_1vector.html#a214ecc697d517f1b0d2d64e03e797fde">更多...</a><br /></td></tr>
<tr class="separator:a214ecc697d517f1b0d2d64e03e797fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5558c764351f91ce8b330978c1406353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a5558c764351f91ce8b330978c1406353">operator=</a> (<a class="el" href="clasststl_1_1vector.html">vector</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a5558c764351f91ce8b330978c1406353"><td class="mdescLeft">&#160;</td><td class="mdescRight">移动赋值运算符。  <a href="clasststl_1_1vector.html#a5558c764351f91ce8b330978c1406353">更多...</a><br /></td></tr>
<tr class="separator:a5558c764351f91ce8b330978c1406353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f76c373e1295638d8d8b8c7d56f649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a66f76c373e1295638d8d8b8c7d56f649">operator=</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a66f76c373e1295638d8d8b8c7d56f649"><td class="mdescLeft">&#160;</td><td class="mdescRight">以 count 份 value 的副本替换内容。  <a href="clasststl_1_1vector.html#a66f76c373e1295638d8d8b8c7d56f649">更多...</a><br /></td></tr>
<tr class="separator:a66f76c373e1295638d8d8b8c7d56f649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937c0f4db11ae47bc238b30d8cd2ef56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a937c0f4db11ae47bc238b30d8cd2ef56">assign</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a937c0f4db11ae47bc238b30d8cd2ef56"><td class="mdescLeft">&#160;</td><td class="mdescRight">以 count 份 value 的副本替换内容。  <a href="clasststl_1_1vector.html#a937c0f4db11ae47bc238b30d8cd2ef56">更多...</a><br /></td></tr>
<tr class="separator:a937c0f4db11ae47bc238b30d8cd2ef56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9331355a234feeeeedf9447d64881b03"><td class="memTemplParams" colspan="2">template&lt;class InputIt , typename  = tstl::_RequireInputIter&lt;InputIt&gt;&gt; </td></tr>
<tr class="memitem:a9331355a234feeeeedf9447d64881b03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a9331355a234feeeeedf9447d64881b03">assign</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a9331355a234feeeeedf9447d64881b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">以范围 [first, last) 中元素的副本替换内容，若任一参数是指向 *this 中的迭代器则行为未定义。  <a href="clasststl_1_1vector.html#a9331355a234feeeeedf9447d64881b03">更多...</a><br /></td></tr>
<tr class="separator:a9331355a234feeeeedf9447d64881b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ec13a9a3a71e3f39e89b7981e143c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a21ec13a9a3a71e3f39e89b7981e143c3">assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a21ec13a9a3a71e3f39e89b7981e143c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">以来自 initializer_list ilist 的元素替换内容。  <a href="clasststl_1_1vector.html#a21ec13a9a3a71e3f39e89b7981e143c3">更多...</a><br /></td></tr>
<tr class="separator:a21ec13a9a3a71e3f39e89b7981e143c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f9e7e74884ea4a76c56ebb9042a8a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#add935423202d90f30acd218e7bc8ea53">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a70f9e7e74884ea4a76c56ebb9042a8a6">get_allocator</a> () const</td></tr>
<tr class="memdesc:a70f9e7e74884ea4a76c56ebb9042a8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回与容器关联的分配器。  <a href="clasststl_1_1vector.html#a70f9e7e74884ea4a76c56ebb9042a8a6">更多...</a><br /></td></tr>
<tr class="separator:a70f9e7e74884ea4a76c56ebb9042a8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c657d7d0241b45499c59b50c060901b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a22b239647222218d41379b3411ebe669">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a1c657d7d0241b45499c59b50c060901b">at</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> pos)</td></tr>
<tr class="memdesc:a1c657d7d0241b45499c59b50c060901b"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回位于指定位置 pos 的元素的引用，有边界检查。 若 pos 不在容器范围内，则抛出 std::out_of_range 类型的异常。  <a href="clasststl_1_1vector.html#a1c657d7d0241b45499c59b50c060901b">更多...</a><br /></td></tr>
<tr class="separator:a1c657d7d0241b45499c59b50c060901b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d359df4378d46afa40cf7f721d616d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a569b30003ae874f7cfa0aa87491c8e33">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a98d359df4378d46afa40cf7f721d616d">at</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> pos) const</td></tr>
<tr class="memdesc:a98d359df4378d46afa40cf7f721d616d"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回位于指定位置 pos 的元素的引用，有边界检查。 若 pos 不在容器范围内，则抛出 std::out_of_range 类型的异常。  <a href="clasststl_1_1vector.html#a98d359df4378d46afa40cf7f721d616d">更多...</a><br /></td></tr>
<tr class="separator:a98d359df4378d46afa40cf7f721d616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d6413fee09b96b80878c1065f618a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a22b239647222218d41379b3411ebe669">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a682d6413fee09b96b80878c1065f618a">operator[]</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> pos)</td></tr>
<tr class="memdesc:a682d6413fee09b96b80878c1065f618a"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回位于指定位置 pos 的元素的引用。不进行边界检查。  <a href="clasststl_1_1vector.html#a682d6413fee09b96b80878c1065f618a">更多...</a><br /></td></tr>
<tr class="separator:a682d6413fee09b96b80878c1065f618a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5961842d0d239a1d85073e939bcd63f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a569b30003ae874f7cfa0aa87491c8e33">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a5961842d0d239a1d85073e939bcd63f7">operator[]</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> pos) const</td></tr>
<tr class="memdesc:a5961842d0d239a1d85073e939bcd63f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回位于指定位置 pos 的元素的引用。不进行边界检查。  <a href="clasststl_1_1vector.html#a5961842d0d239a1d85073e939bcd63f7">更多...</a><br /></td></tr>
<tr class="separator:a5961842d0d239a1d85073e939bcd63f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25185888b64d8bbb8bdcff651ea372d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a22b239647222218d41379b3411ebe669">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a25185888b64d8bbb8bdcff651ea372d8">front</a> ()</td></tr>
<tr class="memdesc:a25185888b64d8bbb8bdcff651ea372d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回到容器首元素的引用。  <a href="clasststl_1_1vector.html#a25185888b64d8bbb8bdcff651ea372d8">更多...</a><br /></td></tr>
<tr class="separator:a25185888b64d8bbb8bdcff651ea372d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c48d24b525ee5a87ee227971836ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a569b30003ae874f7cfa0aa87491c8e33">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a42c48d24b525ee5a87ee227971836ab7">front</a> () const</td></tr>
<tr class="memdesc:a42c48d24b525ee5a87ee227971836ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回到容器首元素的引用。  <a href="clasststl_1_1vector.html#a42c48d24b525ee5a87ee227971836ab7">更多...</a><br /></td></tr>
<tr class="separator:a42c48d24b525ee5a87ee227971836ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7cd33766b3765c9d5d71a8b6f6bc01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a22b239647222218d41379b3411ebe669">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#adc7cd33766b3765c9d5d71a8b6f6bc01">back</a> ()</td></tr>
<tr class="memdesc:adc7cd33766b3765c9d5d71a8b6f6bc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回到容器中最后一个元素的引用。  <a href="clasststl_1_1vector.html#adc7cd33766b3765c9d5d71a8b6f6bc01">更多...</a><br /></td></tr>
<tr class="separator:adc7cd33766b3765c9d5d71a8b6f6bc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f073686898f104148833ccdb8d7789e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a569b30003ae874f7cfa0aa87491c8e33">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a9f073686898f104148833ccdb8d7789e">back</a> () const</td></tr>
<tr class="memdesc:a9f073686898f104148833ccdb8d7789e"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回到容器中最后一个元素的引用。  <a href="clasststl_1_1vector.html#a9f073686898f104148833ccdb8d7789e">更多...</a><br /></td></tr>
<tr class="separator:a9f073686898f104148833ccdb8d7789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947c28c5f35469aecb596e78c30baa2"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a7947c28c5f35469aecb596e78c30baa2">data</a> ()</td></tr>
<tr class="memdesc:a7947c28c5f35469aecb596e78c30baa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向作为元素存储工作的底层数组的指针。  <a href="clasststl_1_1vector.html#a7947c28c5f35469aecb596e78c30baa2">更多...</a><br /></td></tr>
<tr class="separator:a7947c28c5f35469aecb596e78c30baa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7171f348f9ce1e7cb3d0b0c181dce4c6"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a7171f348f9ce1e7cb3d0b0c181dce4c6">data</a> () const</td></tr>
<tr class="memdesc:a7171f348f9ce1e7cb3d0b0c181dce4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向作为元素存储工作的底层数组的指针。  <a href="clasststl_1_1vector.html#a7171f348f9ce1e7cb3d0b0c181dce4c6">更多...</a><br /></td></tr>
<tr class="separator:a7171f348f9ce1e7cb3d0b0c181dce4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6552a26d15fc9958adbc14032577f67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#ae6552a26d15fc9958adbc14032577f67">begin</a> ()</td></tr>
<tr class="memdesc:ae6552a26d15fc9958adbc14032577f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向 vector 首元素的迭代器。  <a href="clasststl_1_1vector.html#ae6552a26d15fc9958adbc14032577f67">更多...</a><br /></td></tr>
<tr class="separator:ae6552a26d15fc9958adbc14032577f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57fcfe119f853e117c048a657def278"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#ad57fcfe119f853e117c048a657def278">begin</a> () const</td></tr>
<tr class="memdesc:ad57fcfe119f853e117c048a657def278"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向 vector 首元素的迭代器。  <a href="clasststl_1_1vector.html#ad57fcfe119f853e117c048a657def278">更多...</a><br /></td></tr>
<tr class="separator:ad57fcfe119f853e117c048a657def278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af781c7b8c202f2066b04f678489a1aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#af781c7b8c202f2066b04f678489a1aa8">cbegin</a> () const</td></tr>
<tr class="memdesc:af781c7b8c202f2066b04f678489a1aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向 vector 首元素的迭代器。  <a href="clasststl_1_1vector.html#af781c7b8c202f2066b04f678489a1aa8">更多...</a><br /></td></tr>
<tr class="separator:af781c7b8c202f2066b04f678489a1aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239a58b3ab5c6fc7a0fa235790b9364e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a239a58b3ab5c6fc7a0fa235790b9364e">end</a> ()</td></tr>
<tr class="memdesc:a239a58b3ab5c6fc7a0fa235790b9364e"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向 vector 末元素后一元素的迭代器。  <a href="clasststl_1_1vector.html#a239a58b3ab5c6fc7a0fa235790b9364e">更多...</a><br /></td></tr>
<tr class="separator:a239a58b3ab5c6fc7a0fa235790b9364e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89b26fdf616f8bc63ddbbef4fc7e4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#af89b26fdf616f8bc63ddbbef4fc7e4c6">end</a> () const</td></tr>
<tr class="memdesc:af89b26fdf616f8bc63ddbbef4fc7e4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向 vector 末元素后一元素的迭代器。  <a href="clasststl_1_1vector.html#af89b26fdf616f8bc63ddbbef4fc7e4c6">更多...</a><br /></td></tr>
<tr class="separator:af89b26fdf616f8bc63ddbbef4fc7e4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f94b04071a29b2666753bf8bb52f017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a9f94b04071a29b2666753bf8bb52f017">cend</a> () const</td></tr>
<tr class="memdesc:a9f94b04071a29b2666753bf8bb52f017"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向 vector 末元素后一元素的迭代器。  <a href="clasststl_1_1vector.html#a9f94b04071a29b2666753bf8bb52f017">更多...</a><br /></td></tr>
<tr class="separator:a9f94b04071a29b2666753bf8bb52f017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815b8a0011b20b005276762034b07c56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a287887267f1d559fdec764f0027deb3a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a815b8a0011b20b005276762034b07c56">rbegin</a> ()</td></tr>
<tr class="memdesc:a815b8a0011b20b005276762034b07c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向逆向 vector 首元素的逆向迭代器。  <a href="clasststl_1_1vector.html#a815b8a0011b20b005276762034b07c56">更多...</a><br /></td></tr>
<tr class="separator:a815b8a0011b20b005276762034b07c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa1bbc780f8c8fa352d758117e06aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#aea949cba6e24f77f55b2cf2861fe4602">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a1fa1bbc780f8c8fa352d758117e06aac">crbegin</a> () const</td></tr>
<tr class="memdesc:a1fa1bbc780f8c8fa352d758117e06aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向逆向 vector 首元素的逆向迭代器。  <a href="clasststl_1_1vector.html#a1fa1bbc780f8c8fa352d758117e06aac">更多...</a><br /></td></tr>
<tr class="separator:a1fa1bbc780f8c8fa352d758117e06aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f91f2aa8c05813293cd6b3f35eb6b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a8f91f2aa8c05813293cd6b3f35eb6b29">rbegin</a> () const</td></tr>
<tr class="memdesc:a8f91f2aa8c05813293cd6b3f35eb6b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向逆向 vector 首元素的逆向迭代器。  <a href="clasststl_1_1vector.html#a8f91f2aa8c05813293cd6b3f35eb6b29">更多...</a><br /></td></tr>
<tr class="separator:a8f91f2aa8c05813293cd6b3f35eb6b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228506857923b5a136515dee5782f87e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a287887267f1d559fdec764f0027deb3a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a228506857923b5a136515dee5782f87e">rend</a> ()</td></tr>
<tr class="memdesc:a228506857923b5a136515dee5782f87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向逆向 vector 末元素后一元素的逆向迭代器。  <a href="clasststl_1_1vector.html#a228506857923b5a136515dee5782f87e">更多...</a><br /></td></tr>
<tr class="separator:a228506857923b5a136515dee5782f87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa021e9e9aa2678aa1365099300650ab4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#aea949cba6e24f77f55b2cf2861fe4602">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#aa021e9e9aa2678aa1365099300650ab4">rend</a> () const</td></tr>
<tr class="memdesc:aa021e9e9aa2678aa1365099300650ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向逆向 vector 末元素后一元素的逆向迭代器。  <a href="clasststl_1_1vector.html#aa021e9e9aa2678aa1365099300650ab4">更多...</a><br /></td></tr>
<tr class="separator:aa021e9e9aa2678aa1365099300650ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f681ade0b2495f3afa15d431ef8a70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#aea949cba6e24f77f55b2cf2861fe4602">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a64f681ade0b2495f3afa15d431ef8a70">crend</a> () const</td></tr>
<tr class="memdesc:a64f681ade0b2495f3afa15d431ef8a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回指向逆向 vector 末元素后一元素的逆向迭代器。  <a href="clasststl_1_1vector.html#a64f681ade0b2495f3afa15d431ef8a70">更多...</a><br /></td></tr>
<tr class="separator:a64f681ade0b2495f3afa15d431ef8a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8227f380a0a0011a8f094ae5d379b272"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a8227f380a0a0011a8f094ae5d379b272">empty</a> () const</td></tr>
<tr class="memdesc:a8227f380a0a0011a8f094ae5d379b272"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查容器是否无元素。  <a href="clasststl_1_1vector.html#a8227f380a0a0011a8f094ae5d379b272">更多...</a><br /></td></tr>
<tr class="separator:a8227f380a0a0011a8f094ae5d379b272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b825152cd32b169b614f3b0af796ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a1b825152cd32b169b614f3b0af796ba9">size</a> () const</td></tr>
<tr class="memdesc:a1b825152cd32b169b614f3b0af796ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回容器中的元素数。  <a href="clasststl_1_1vector.html#a1b825152cd32b169b614f3b0af796ba9">更多...</a><br /></td></tr>
<tr class="separator:a1b825152cd32b169b614f3b0af796ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4680c7a84e7b87770a0d7e58b9334db0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a4680c7a84e7b87770a0d7e58b9334db0">max_size</a> () const</td></tr>
<tr class="memdesc:a4680c7a84e7b87770a0d7e58b9334db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回根据系统或库实现限制的容器可保有的元素最大数量。  <a href="clasststl_1_1vector.html#a4680c7a84e7b87770a0d7e58b9334db0">更多...</a><br /></td></tr>
<tr class="separator:a4680c7a84e7b87770a0d7e58b9334db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8071acd8ca1e85cfdd508525ca8da229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a8071acd8ca1e85cfdd508525ca8da229">reserve</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> new_cap)</td></tr>
<tr class="memdesc:a8071acd8ca1e85cfdd508525ca8da229"><td class="mdescLeft">&#160;</td><td class="mdescRight">增加 vector 的容量到大于或等于 new_cap 的值。  <a href="clasststl_1_1vector.html#a8071acd8ca1e85cfdd508525ca8da229">更多...</a><br /></td></tr>
<tr class="separator:a8071acd8ca1e85cfdd508525ca8da229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cca2b7e5ea48faf151969e8905f605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#af5cca2b7e5ea48faf151969e8905f605">capacity</a> () const</td></tr>
<tr class="memdesc:af5cca2b7e5ea48faf151969e8905f605"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回容器当前已为之分配空间的元素数。  <a href="clasststl_1_1vector.html#af5cca2b7e5ea48faf151969e8905f605">更多...</a><br /></td></tr>
<tr class="separator:af5cca2b7e5ea48faf151969e8905f605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d1dcfdcca5da25eada44d3202d0d03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a13d1dcfdcca5da25eada44d3202d0d03">shrink_to_fit</a> ()</td></tr>
<tr class="separator:a13d1dcfdcca5da25eada44d3202d0d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ec3706066d423a3204f57984085d43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a57ec3706066d423a3204f57984085d43">clear</a> ()</td></tr>
<tr class="memdesc:a57ec3706066d423a3204f57984085d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">从容器擦除所有元素。此调用后 <a class="el" href="clasststl_1_1vector.html#a1b825152cd32b169b614f3b0af796ba9" title="返回容器中的元素数。">size()</a> 返回零。  <a href="clasststl_1_1vector.html#a57ec3706066d423a3204f57984085d43">更多...</a><br /></td></tr>
<tr class="separator:a57ec3706066d423a3204f57984085d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880076e37b7af9a14308acb5f357451e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a880076e37b7af9a14308acb5f357451e">insert</a> (<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> pos, const T &amp;value)</td></tr>
<tr class="memdesc:a880076e37b7af9a14308acb5f357451e"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置 pos 前插入 value。  <a href="clasststl_1_1vector.html#a880076e37b7af9a14308acb5f357451e">更多...</a><br /></td></tr>
<tr class="separator:a880076e37b7af9a14308acb5f357451e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345a81153e50982d054298baf68ac6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a345a81153e50982d054298baf68ac6e4">insert</a> (<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> pos, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a345a81153e50982d054298baf68ac6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置 pos 前插入 value。  <a href="clasststl_1_1vector.html#a345a81153e50982d054298baf68ac6e4">更多...</a><br /></td></tr>
<tr class="separator:a345a81153e50982d054298baf68ac6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac081a0406712bccdb1fa874c058ffe89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#ac081a0406712bccdb1fa874c058ffe89">insert</a> (<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> pos, <a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:ac081a0406712bccdb1fa874c058ffe89"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置 pos 前插入 value 的 count 个副本。  <a href="clasststl_1_1vector.html#ac081a0406712bccdb1fa874c058ffe89">更多...</a><br /></td></tr>
<tr class="separator:ac081a0406712bccdb1fa874c058ffe89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe83ee74c8b5223555fdfbe5a618def"><td class="memTemplParams" colspan="2">template&lt;class InputIt , typename  = tstl::_RequireInputIter&lt;InputIt&gt;&gt; </td></tr>
<tr class="memitem:a1fe83ee74c8b5223555fdfbe5a618def"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a1fe83ee74c8b5223555fdfbe5a618def">insert</a> (<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> pos, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a1fe83ee74c8b5223555fdfbe5a618def"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置 pos 前插入来自 [first, last) 的元素。  <a href="clasststl_1_1vector.html#a1fe83ee74c8b5223555fdfbe5a618def">更多...</a><br /></td></tr>
<tr class="separator:a1fe83ee74c8b5223555fdfbe5a618def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e68a5c4011d5327fef35eea00790d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a67e68a5c4011d5327fef35eea00790d2">insert</a> (<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> pos, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a67e68a5c4011d5327fef35eea00790d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置 pos 前插入来自 initializer_list 的元素。  <a href="clasststl_1_1vector.html#a67e68a5c4011d5327fef35eea00790d2">更多...</a><br /></td></tr>
<tr class="separator:a67e68a5c4011d5327fef35eea00790d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d641ba2c2fc8c3f30a3d173bd0ddbe"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa5d641ba2c2fc8c3f30a3d173bd0ddbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#aa5d641ba2c2fc8c3f30a3d173bd0ddbe">emplace</a> (<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> pos, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aa5d641ba2c2fc8c3f30a3d173bd0ddbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">直接于 pos 前插入元素到容器中。  <a href="clasststl_1_1vector.html#aa5d641ba2c2fc8c3f30a3d173bd0ddbe">更多...</a><br /></td></tr>
<tr class="separator:aa5d641ba2c2fc8c3f30a3d173bd0ddbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75166e1e7097dd9b9deb50050f20827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#af75166e1e7097dd9b9deb50050f20827">erase</a> (<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> pos)</td></tr>
<tr class="memdesc:af75166e1e7097dd9b9deb50050f20827"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置 pos 移除元素。  <a href="clasststl_1_1vector.html#af75166e1e7097dd9b9deb50050f20827">更多...</a><br /></td></tr>
<tr class="separator:af75166e1e7097dd9b9deb50050f20827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf5429b875bfe6ecf979bd9a74d59da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#aecf5429b875bfe6ecf979bd9a74d59da">erase</a> (<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> first, <a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> last)</td></tr>
<tr class="memdesc:aecf5429b875bfe6ecf979bd9a74d59da"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除范围 [first, last) 中的元素。  <a href="clasststl_1_1vector.html#aecf5429b875bfe6ecf979bd9a74d59da">更多...</a><br /></td></tr>
<tr class="separator:aecf5429b875bfe6ecf979bd9a74d59da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a828879e126fe22cc8f138fea9540e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a6a828879e126fe22cc8f138fea9540e9">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a6a828879e126fe22cc8f138fea9540e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化新元素为 value 的副本。  <a href="clasststl_1_1vector.html#a6a828879e126fe22cc8f138fea9540e9">更多...</a><br /></td></tr>
<tr class="separator:a6a828879e126fe22cc8f138fea9540e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf85f1988d7a77c783d0b30cbae84c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#aacf85f1988d7a77c783d0b30cbae84c5">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:aacf85f1988d7a77c783d0b30cbae84c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">移动 value 进新元素。  <a href="clasststl_1_1vector.html#aacf85f1988d7a77c783d0b30cbae84c5">更多...</a><br /></td></tr>
<tr class="separator:aacf85f1988d7a77c783d0b30cbae84c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10559c38927a8ce08b0400bd5aed6581"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a10559c38927a8ce08b0400bd5aed6581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a10559c38927a8ce08b0400bd5aed6581">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a10559c38927a8ce08b0400bd5aed6581"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加新元素到容器尾。  <a href="clasststl_1_1vector.html#a10559c38927a8ce08b0400bd5aed6581">更多...</a><br /></td></tr>
<tr class="separator:a10559c38927a8ce08b0400bd5aed6581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1165177fc242f539d513b607b609ddc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a1165177fc242f539d513b607b609ddc8">pop_back</a> ()</td></tr>
<tr class="memdesc:a1165177fc242f539d513b607b609ddc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除容器的末元素。  <a href="clasststl_1_1vector.html#a1165177fc242f539d513b607b609ddc8">更多...</a><br /></td></tr>
<tr class="separator:a1165177fc242f539d513b607b609ddc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb21c0d431a88f8eceee1fdbbba50ad5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#acb21c0d431a88f8eceee1fdbbba50ad5">resize</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> new_size)</td></tr>
<tr class="memdesc:acb21c0d431a88f8eceee1fdbbba50ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">重设容器大小以容纳 new_size 个元素，多余元素是默认元素。  <a href="clasststl_1_1vector.html#acb21c0d431a88f8eceee1fdbbba50ad5">更多...</a><br /></td></tr>
<tr class="separator:acb21c0d431a88f8eceee1fdbbba50ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ef1feeb87940e0547b8832bec81d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a15ef1feeb87940e0547b8832bec81d3f">resize</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> new_size, const <a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a15ef1feeb87940e0547b8832bec81d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">重设容器大小以容纳 new_size 个元素，多余元素是 value 的副本。  <a href="clasststl_1_1vector.html#a15ef1feeb87940e0547b8832bec81d3f">更多...</a><br /></td></tr>
<tr class="separator:a15ef1feeb87940e0547b8832bec81d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a34c8e7d71f511581d32fb1391167a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a8a34c8e7d71f511581d32fb1391167a9">swap</a> (<a class="el" href="clasststl_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:a8a34c8e7d71f511581d32fb1391167a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">与 other 的交换。  <a href="clasststl_1_1vector.html#a8a34c8e7d71f511581d32fb1391167a9">更多...</a><br /></td></tr>
<tr class="separator:a8a34c8e7d71f511581d32fb1391167a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected 成员函数</h2></td></tr>
<tr class="memitem:a12f26049a37cce24591f019a93f400a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a12f26049a37cce24591f019a93f400a5">m_allocate</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> count)</td></tr>
<tr class="separator:a12f26049a37cce24591f019a93f400a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0a2f4db9cfac750d1d2009a3a59e63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a8d0a2f4db9cfac750d1d2009a3a59e63">m_deallocate</a> (<a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> p, <a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> count)</td></tr>
<tr class="separator:a8d0a2f4db9cfac750d1d2009a3a59e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19476c2bcd9efcbc25ae1ecf639d7297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a19476c2bcd9efcbc25ae1ecf639d7297">m_destroy</a> (<a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> p)</td></tr>
<tr class="separator:a19476c2bcd9efcbc25ae1ecf639d7297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3384484460fcbea0762cb3ddca7b9bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a3384484460fcbea0762cb3ddca7b9bb9">m_destroy</a> (<a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> first, <a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> last)</td></tr>
<tr class="separator:a3384484460fcbea0762cb3ddca7b9bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99066507afd65b9b50c96deed3ecf943"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a99066507afd65b9b50c96deed3ecf943"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a99066507afd65b9b50c96deed3ecf943">m_construct</a> (<a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> p, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a99066507afd65b9b50c96deed3ecf943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0620f0252b73c25593d0246e35367943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a0620f0252b73c25593d0246e35367943">m_create_storage</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> count)</td></tr>
<tr class="separator:a0620f0252b73c25593d0246e35367943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbe70ee19228e9456af7307474a1160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a9dbe70ee19228e9456af7307474a1160">m_default_init</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> count)</td></tr>
<tr class="separator:a9dbe70ee19228e9456af7307474a1160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24539447fd133658cf48fd2e5ccb3dae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a24539447fd133658cf48fd2e5ccb3dae">m_fill_init</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> count, const <a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> &amp;value)</td></tr>
<tr class="separator:a24539447fd133658cf48fd2e5ccb3dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40ec5ee95d6015c38a32acad7c697d0"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename ForwardIter &gt; </td></tr>
<tr class="memitem:aa40ec5ee95d6015c38a32acad7c697d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#aa40ec5ee95d6015c38a32acad7c697d0">m_uninitialized_copy</a> (InputIter first, InputIter last, ForwardIter result)</td></tr>
<tr class="separator:aa40ec5ee95d6015c38a32acad7c697d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faa93f46e3a3082857587352bfd534b"><td class="memTemplParams" colspan="2">template&lt;class Arg &gt; </td></tr>
<tr class="memitem:a0faa93f46e3a3082857587352bfd534b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a0faa93f46e3a3082857587352bfd534b">m_insert_aux</a> (<a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> pos, Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a0faa93f46e3a3082857587352bfd534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dcd5fc00175dbbd5e8c779078f431e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#ad0dcd5fc00175dbbd5e8c779078f431e">m_erase_at_end</a> (<a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> pos)</td></tr>
<tr class="separator:ad0dcd5fc00175dbbd5e8c779078f431e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac475cc0cf75725f387645987c36b0358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#ac475cc0cf75725f387645987c36b0358">m_insert_rval</a> (<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> pos, T &amp;&amp;value)</td></tr>
<tr class="separator:ac475cc0cf75725f387645987c36b0358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afe6df486479af89da2b55e2a7398ae"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:a9afe6df486479af89da2b55e2a7398ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a9afe6df486479af89da2b55e2a7398ae">m_assign_aux</a> (InputIt first, InputIt last, <a class="el" href="structtstl_1_1input__iterator__tag.html">input_iterator_tag</a>)</td></tr>
<tr class="separator:a9afe6df486479af89da2b55e2a7398ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3898fa64809482d2f2ba09869f35e39f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:a3898fa64809482d2f2ba09869f35e39f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a3898fa64809482d2f2ba09869f35e39f">m_assign_aux</a> (ForwardIt first, ForwardIt last, <a class="el" href="structtstl_1_1forward__iterator__tag.html">forward_iterator_tag</a>)</td></tr>
<tr class="separator:a3898fa64809482d2f2ba09869f35e39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b56e14f6bd7f19ce4af766d182114d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a3b56e14f6bd7f19ce4af766d182114d6">m_fill_assign</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> count, const <a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> &amp;value)</td></tr>
<tr class="separator:a3b56e14f6bd7f19ce4af766d182114d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd527e540d73533bf6a99e8ab6a6126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a8cd527e540d73533bf6a99e8ab6a6126">m_swap_data</a> (<a class="el" href="clasststl_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="separator:a8cd527e540d73533bf6a99e8ab6a6126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f99c20a18d052faecfa25e8e7245ad"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ad6f99c20a18d052faecfa25e8e7245ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#ad6f99c20a18d052faecfa25e8e7245ad">m_insert_dispatch</a> (<a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> pos, InputIt first, InputIt last, <a class="el" href="namespacetstl.html#a32942c5bc5b0dc643cc1dee73a8a04dc">false_type</a>)</td></tr>
<tr class="separator:ad6f99c20a18d052faecfa25e8e7245ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39987132808ac64819bc12f38108b77d"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt &gt; </td></tr>
<tr class="memitem:a39987132808ac64819bc12f38108b77d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a39987132808ac64819bc12f38108b77d">m_range_insert</a> (<a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> pos, ForwardIt first, ForwardIt last, <a class="el" href="structtstl_1_1forward__iterator__tag.html">tstl::forward_iterator_tag</a>)</td></tr>
<tr class="separator:a39987132808ac64819bc12f38108b77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409e4499885e4a5e9878faf0e75bafc7"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a409e4499885e4a5e9878faf0e75bafc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a409e4499885e4a5e9878faf0e75bafc7">m_assign_dispatch</a> (InputIt first, InputIt last, <a class="el" href="namespacetstl.html#a32942c5bc5b0dc643cc1dee73a8a04dc">false_type</a>)</td></tr>
<tr class="separator:a409e4499885e4a5e9878faf0e75bafc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726db10dc0b39a72e26071d15319b6a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a726db10dc0b39a72e26071d15319b6a7">m_fill_insert</a> (<a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> pos, <a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> n, const T &amp;value)</td></tr>
<tr class="separator:a726db10dc0b39a72e26071d15319b6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5055d45250ebc1a3ed8f6343a4f673c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a5055d45250ebc1a3ed8f6343a4f673c5">m_move_assign</a> (<a class="el" href="clasststl_1_1vector.html">vector</a> &amp;&amp;other)</td></tr>
<tr class="separator:a5055d45250ebc1a3ed8f6343a4f673c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b177fbc03113e51f188bf8f7aa8445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#aa2b177fbc03113e51f188bf8f7aa8445">m_emplace_aux</a> (<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> pos, T &amp;&amp;value)</td></tr>
<tr class="separator:aa2b177fbc03113e51f188bf8f7aa8445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b145a396bd249b7fcd19336950393b"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac5b145a396bd249b7fcd19336950393b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#ac5b145a396bd249b7fcd19336950393b">m_realloc_insert</a> (<a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> pos, Args &amp;&amp;...args)</td></tr>
<tr class="separator:ac5b145a396bd249b7fcd19336950393b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e18f95268803467ca3025ee4b0ec65"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a15e18f95268803467ca3025ee4b0ec65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a15e18f95268803467ca3025ee4b0ec65">m_range_init</a> (InputIt first, InputIt last, <a class="el" href="structtstl_1_1input__iterator__tag.html">tstl::input_iterator_tag</a>)</td></tr>
<tr class="separator:a15e18f95268803467ca3025ee4b0ec65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d19b608e591288a981368566a3c3359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a9d19b608e591288a981368566a3c3359">m_check_len</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> n) const</td></tr>
<tr class="separator:a9d19b608e591288a981368566a3c3359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ec6a37002a7382afc5129b2c8433b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a66ec6a37002a7382afc5129b2c8433b0">m_erase</a> (<a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> pos)</td></tr>
<tr class="separator:a66ec6a37002a7382afc5129b2c8433b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd3cba4e3d76479582c8ff137f80f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a9dd3cba4e3d76479582c8ff137f80f05">m_erase</a> (<a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> first, <a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> last)</td></tr>
<tr class="separator:a9dd3cba4e3d76479582c8ff137f80f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ac7cb6998cf7c226202beedda4b70d"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt &gt; </td></tr>
<tr class="memitem:a63ac7cb6998cf7c226202beedda4b70d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a63ac7cb6998cf7c226202beedda4b70d">m_range_init</a> (ForwardIt first, ForwardIt last, <a class="el" href="structtstl_1_1forward__iterator__tag.html">tstl::forward_iterator_tag</a>)</td></tr>
<tr class="separator:a63ac7cb6998cf7c226202beedda4b70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a590b5e3e9418d3827da36cb6bbd99a"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt &gt; </td></tr>
<tr class="memitem:a3a590b5e3e9418d3827da36cb6bbd99a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a3a590b5e3e9418d3827da36cb6bbd99a">m_allocate_and_copy</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> n, ForwardIt first, ForwardIt last)</td></tr>
<tr class="separator:a3a590b5e3e9418d3827da36cb6bbd99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911aa142576b8b9187662855c4f05b4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a911aa142576b8b9187662855c4f05b4f">m_default_append</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> n)</td></tr>
<tr class="separator:a911aa142576b8b9187662855c4f05b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d3c3bbf24aca0b06ccffd314771a53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a85d3c3bbf24aca0b06ccffd314771a53">m_range_check</a> (<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> pos)</td></tr>
<tr class="memdesc:a85d3c3bbf24aca0b06ccffd314771a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">越界检查，仅被 <a class="el" href="clasststl_1_1vector.html#a1c657d7d0241b45499c59b50c060901b" title="返回位于指定位置 pos 的元素的引用，有边界检查。 若 pos 不在容器范围内，则抛出 std::out_of_range 类型的异常。">at()</a> 使用。  <a href="clasststl_1_1vector.html#a85d3c3bbf24aca0b06ccffd314771a53">更多...</a><br /></td></tr>
<tr class="separator:a85d3c3bbf24aca0b06ccffd314771a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected 属性</h2></td></tr>
<tr class="memitem:a5fe90893b20178bfb10fd95b60188566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a5fe90893b20178bfb10fd95b60188566">m_start</a> = nullptr</td></tr>
<tr class="separator:a5fe90893b20178bfb10fd95b60188566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff94dd48bda4d0c530a5806866750d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#aeff94dd48bda4d0c530a5806866750d9">m_finish</a> = nullptr</td></tr>
<tr class="separator:aeff94dd48bda4d0c530a5806866750d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657109d42ce87a09af5f007251330901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a657109d42ce87a09af5f007251330901">m_end_of_storage</a> = nullptr</td></tr>
<tr class="separator:a657109d42ce87a09af5f007251330901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461fcfe25d20d79e086b31442ffb264b"><td class="memItemLeft" align="right" valign="top">Allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a461fcfe25d20d79e086b31442ffb264b">m_alloc</a></td></tr>
<tr class="separator:a461fcfe25d20d79e086b31442ffb264b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private 类型</h2></td></tr>
<tr class="memitem:a270ae1328ac40b2621a219eefc1fb8b5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a270ae1328ac40b2621a219eefc1fb8b5">alloc_traits</a> = std::allocator_traits&lt; Allocator &gt;</td></tr>
<tr class="separator:a270ae1328ac40b2621a219eefc1fb8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
友元</h2></td></tr>
<tr class="memitem:a33679563540934e4c3e487aa12a63424"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clasststl_1_1vector.html#a33679563540934e4c3e487aa12a63424">operator==</a> (const <a class="el" href="clasststl_1_1vector.html">vector</a> &amp;lhs, const <a class="el" href="clasststl_1_1vector.html">vector</a> &amp;rhs)</td></tr>
<tr class="separator:a33679563540934e4c3e487aa12a63424"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">成员类型定义说明</h2>
<a id="a270ae1328ac40b2621a219eefc1fb8b5" name="a270ae1328ac40b2621a219eefc1fb8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270ae1328ac40b2621a219eefc1fb8b5">&#9670;&nbsp;</a></span>alloc_traits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#a270ae1328ac40b2621a219eefc1fb8b5">alloc_traits</a> =  std::allocator_traits&lt;Allocator&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa01279e0dee0bbf9d275b336625b1205" name="aa01279e0dee0bbf9d275b336625b1205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01279e0dee0bbf9d275b336625b1205">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add935423202d90f30acd218e7bc8ea53" name="add935423202d90f30acd218e7bc8ea53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add935423202d90f30acd218e7bc8ea53">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#add935423202d90f30acd218e7bc8ea53">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abed80c6c1ade9ac7baca57a633effd1c" name="abed80c6c1ade9ac7baca57a633effd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed80c6c1ade9ac7baca57a633effd1c">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4523b0c1d86d385aeafbbbc2ae4a39d" name="ac4523b0c1d86d385aeafbbbc2ae4a39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4523b0c1d86d385aeafbbbc2ae4a39d">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#ac4523b0c1d86d385aeafbbbc2ae4a39d">difference_type</a> =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22b239647222218d41379b3411ebe669" name="a22b239647222218d41379b3411ebe669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b239647222218d41379b3411ebe669">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#a22b239647222218d41379b3411ebe669">reference</a> =  <a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a569b30003ae874f7cfa0aa87491c8e33" name="a569b30003ae874f7cfa0aa87491c8e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569b30003ae874f7cfa0aa87491c8e33">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#a569b30003ae874f7cfa0aa87491c8e33">const_reference</a> =  const <a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b425422d70c1926bffddbff35291402" name="a2b425422d70c1926bffddbff35291402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b425422d70c1926bffddbff35291402">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> =  typename alloc_traits::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7263ad3876f0df996ee585e1b6460499" name="a7263ad3876f0df996ee585e1b6460499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7263ad3876f0df996ee585e1b6460499">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#a7263ad3876f0df996ee585e1b6460499">const_pointer</a> =  typename alloc_traits::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2099f0a30068ff2976dfa9ab63a683f9" name="a2099f0a30068ff2976dfa9ab63a683f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2099f0a30068ff2976dfa9ab63a683f9">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> =  tstl::_normal_iterator&lt;T *, <a class="el" href="clasststl_1_1vector.html">vector</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b6df383347f89966f8361ccd94fa4dc" name="a8b6df383347f89966f8361ccd94fa4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6df383347f89966f8361ccd94fa4dc">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> =  tstl::_normal_iterator&lt;const T *, <a class="el" href="clasststl_1_1vector.html">vector</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a287887267f1d559fdec764f0027deb3a" name="a287887267f1d559fdec764f0027deb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287887267f1d559fdec764f0027deb3a">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#a287887267f1d559fdec764f0027deb3a">reverse_iterator</a> =  tstl::reverse_iterator&lt;<a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea949cba6e24f77f55b2cf2861fe4602" name="aea949cba6e24f77f55b2cf2861fe4602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea949cba6e24f77f55b2cf2861fe4602">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html#aea949cba6e24f77f55b2cf2861fe4602">const_reverse_iterator</a> =  tstl::reverse_iterator&lt;<a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a id="aceefe3284d5d7bb394cef4b2435a25d3" name="aceefe3284d5d7bb394cef4b2435a25d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceefe3284d5d7bb394cef4b2435a25d3">&#9670;&nbsp;</a></span>vector() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>默认构造函数。构造拥有默认构造的分配器的空容器。 </p>

</div>
</div>
<a id="abf966113ef059db92132e9d4c02ba5dd" name="abf966113ef059db92132e9d4c02ba5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf966113ef059db92132e9d4c02ba5dd">&#9670;&nbsp;</a></span>vector() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>构造拥有给定分配器 alloc 的空容器。 </p>

</div>
</div>
<a id="a0fb39f1e6ee28c59e637c02e625f85ff" name="a0fb39f1e6ee28c59e637c02e625f85ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb39f1e6ee28c59e637c02e625f85ff">&#9670;&nbsp;</a></span>vector() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>构造拥有 count 个有值 value 的元素的容器。 </p>

</div>
</div>
<a id="adf187d4860e74f9b7121118148cce26e" name="adf187d4860e74f9b7121118148cce26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf187d4860e74f9b7121118148cce26e">&#9670;&nbsp;</a></span>vector() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>构造拥有个 count 默认插入的 T 实例的容器。不进行复制。 </p>

</div>
</div>
<a id="a2e19af70d985afe3d644f1494ebf2bec" name="a2e19af70d985afe3d644f1494ebf2bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e19af70d985afe3d644f1494ebf2bec">&#9670;&nbsp;</a></span>vector() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt , typename  = tstl::_RequireInputIter&lt;InputIt&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>构造拥有范围 [first, last) 内容的容器。 </p>

</div>
</div>
<a id="ac4342d411a6e05bfa4ccb6cd9667ca28" name="ac4342d411a6e05bfa4ccb6cd9667ca28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4342d411a6e05bfa4ccb6cd9667ca28">&#9670;&nbsp;</a></span>vector() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="clasststl_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>复制构造函数。构造拥有 other 内容的容器。 </p>

</div>
</div>
<a id="a615a002ad955dc4ec65b4e8763b5ccad" name="a615a002ad955dc4ec65b4e8763b5ccad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615a002ad955dc4ec65b4e8763b5ccad">&#9670;&nbsp;</a></span>vector() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="clasststl_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>构造拥有 other 内容的容器，以 alloc 为分配器。 </p>

</div>
</div>
<a id="a8f9321300dc4e736ad809e7014449a93" name="a8f9321300dc4e736ad809e7014449a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9321300dc4e736ad809e7014449a93">&#9670;&nbsp;</a></span>vector() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移动构造函数。 </p>

</div>
</div>
<a id="a10ceb74e1354bf68cef3f2ac4aea04b5" name="a10ceb74e1354bf68cef3f2ac4aea04b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ceb74e1354bf68cef3f2ac4aea04b5">&#9670;&nbsp;</a></span>vector() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>有分配器扩展的移动构造函数。 </p>

</div>
</div>
<a id="aea0d0d4d29322e2cd8e86df01a366366" name="aea0d0d4d29322e2cd8e86df01a366366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0d0d4d29322e2cd8e86df01a366366">&#9670;&nbsp;</a></span>vector() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::<a class="el" href="clasststl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>构造拥有 initializer_list 内容的容器。 </p>

</div>
</div>
<a id="a4d7c4744b067c70e2ea50989e7da6822" name="a4d7c4744b067c70e2ea50989e7da6822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7c4744b067c70e2ea50989e7da6822">&#9670;&nbsp;</a></span>~vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::~<a class="el" href="clasststl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>销毁 vector。 </p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a214ecc697d517f1b0d2d64e03e797fde" name="a214ecc697d517f1b0d2d64e03e797fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214ecc697d517f1b0d2d64e03e797fde">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">vector</a> &amp; <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="clasststl_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>复制赋值运算符。 </p>

</div>
</div>
<a id="a5558c764351f91ce8b330978c1406353" name="a5558c764351f91ce8b330978c1406353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5558c764351f91ce8b330978c1406353">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">vector</a> &amp; <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移动赋值运算符。 </p>

</div>
</div>
<a id="a66f76c373e1295638d8d8b8c7d56f649" name="a66f76c373e1295638d8d8b8c7d56f649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f76c373e1295638d8d8b8c7d56f649">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html">vector</a> &amp; <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>以 count 份 value 的副本替换内容。 </p>

</div>
</div>
<a id="a937c0f4db11ae47bc238b30d8cd2ef56" name="a937c0f4db11ae47bc238b30d8cd2ef56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937c0f4db11ae47bc238b30d8cd2ef56">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>以 count 份 value 的副本替换内容。 </p>

</div>
</div>
<a id="a9331355a234feeeeedf9447d64881b03" name="a9331355a234feeeeedf9447d64881b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9331355a234feeeeedf9447d64881b03">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt , typename  = tstl::_RequireInputIter&lt;InputIt&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>以范围 [first, last) 中元素的副本替换内容，若任一参数是指向 *this 中的迭代器则行为未定义。 </p>

</div>
</div>
<a id="a21ec13a9a3a71e3f39e89b7981e143c3" name="a21ec13a9a3a71e3f39e89b7981e143c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ec13a9a3a71e3f39e89b7981e143c3">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>以来自 initializer_list ilist 的元素替换内容。 </p>

</div>
</div>
<a id="a70f9e7e74884ea4a76c56ebb9042a8a6" name="a70f9e7e74884ea4a76c56ebb9042a8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f9e7e74884ea4a76c56ebb9042a8a6">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#add935423202d90f30acd218e7bc8ea53">allocator_type</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回与容器关联的分配器。 </p>

</div>
</div>
<a id="a1c657d7d0241b45499c59b50c060901b" name="a1c657d7d0241b45499c59b50c060901b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c657d7d0241b45499c59b50c060901b">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a22b239647222218d41379b3411ebe669">reference</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回位于指定位置 pos 的元素的引用，有边界检查。 若 pos 不在容器范围内，则抛出 std::out_of_range 类型的异常。 </p>

</div>
</div>
<a id="a98d359df4378d46afa40cf7f721d616d" name="a98d359df4378d46afa40cf7f721d616d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d359df4378d46afa40cf7f721d616d">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a569b30003ae874f7cfa0aa87491c8e33">const_reference</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回位于指定位置 pos 的元素的引用，有边界检查。 若 pos 不在容器范围内，则抛出 std::out_of_range 类型的异常。 </p>

</div>
</div>
<a id="a682d6413fee09b96b80878c1065f618a" name="a682d6413fee09b96b80878c1065f618a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682d6413fee09b96b80878c1065f618a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a22b239647222218d41379b3411ebe669">reference</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回位于指定位置 pos 的元素的引用。不进行边界检查。 </p>

</div>
</div>
<a id="a5961842d0d239a1d85073e939bcd63f7" name="a5961842d0d239a1d85073e939bcd63f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5961842d0d239a1d85073e939bcd63f7">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a569b30003ae874f7cfa0aa87491c8e33">const_reference</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回位于指定位置 pos 的元素的引用。不进行边界检查。 </p>

</div>
</div>
<a id="a25185888b64d8bbb8bdcff651ea372d8" name="a25185888b64d8bbb8bdcff651ea372d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25185888b64d8bbb8bdcff651ea372d8">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a22b239647222218d41379b3411ebe669">reference</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回到容器首元素的引用。 </p>

</div>
</div>
<a id="a42c48d24b525ee5a87ee227971836ab7" name="a42c48d24b525ee5a87ee227971836ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c48d24b525ee5a87ee227971836ab7">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a569b30003ae874f7cfa0aa87491c8e33">const_reference</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回到容器首元素的引用。 </p>

</div>
</div>
<a id="adc7cd33766b3765c9d5d71a8b6f6bc01" name="adc7cd33766b3765c9d5d71a8b6f6bc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7cd33766b3765c9d5d71a8b6f6bc01">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a22b239647222218d41379b3411ebe669">reference</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回到容器中最后一个元素的引用。 </p>

</div>
</div>
<a id="a9f073686898f104148833ccdb8d7789e" name="a9f073686898f104148833ccdb8d7789e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f073686898f104148833ccdb8d7789e">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a569b30003ae874f7cfa0aa87491c8e33">const_reference</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回到容器中最后一个元素的引用。 </p>

</div>
</div>
<a id="a7947c28c5f35469aecb596e78c30baa2" name="a7947c28c5f35469aecb596e78c30baa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7947c28c5f35469aecb596e78c30baa2">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向作为元素存储工作的底层数组的指针。 </p>

</div>
</div>
<a id="a7171f348f9ce1e7cb3d0b0c181dce4c6" name="a7171f348f9ce1e7cb3d0b0c181dce4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7171f348f9ce1e7cb3d0b0c181dce4c6">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向作为元素存储工作的底层数组的指针。 </p>

</div>
</div>
<a id="ae6552a26d15fc9958adbc14032577f67" name="ae6552a26d15fc9958adbc14032577f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6552a26d15fc9958adbc14032577f67">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向 vector 首元素的迭代器。 </p>

</div>
</div>
<a id="ad57fcfe119f853e117c048a657def278" name="ad57fcfe119f853e117c048a657def278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57fcfe119f853e117c048a657def278">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向 vector 首元素的迭代器。 </p>

</div>
</div>
<a id="af781c7b8c202f2066b04f678489a1aa8" name="af781c7b8c202f2066b04f678489a1aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af781c7b8c202f2066b04f678489a1aa8">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向 vector 首元素的迭代器。 </p>

</div>
</div>
<a id="a239a58b3ab5c6fc7a0fa235790b9364e" name="a239a58b3ab5c6fc7a0fa235790b9364e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239a58b3ab5c6fc7a0fa235790b9364e">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向 vector 末元素后一元素的迭代器。 </p>

</div>
</div>
<a id="af89b26fdf616f8bc63ddbbef4fc7e4c6" name="af89b26fdf616f8bc63ddbbef4fc7e4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89b26fdf616f8bc63ddbbef4fc7e4c6">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向 vector 末元素后一元素的迭代器。 </p>

</div>
</div>
<a id="a9f94b04071a29b2666753bf8bb52f017" name="a9f94b04071a29b2666753bf8bb52f017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f94b04071a29b2666753bf8bb52f017">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向 vector 末元素后一元素的迭代器。 </p>

</div>
</div>
<a id="a815b8a0011b20b005276762034b07c56" name="a815b8a0011b20b005276762034b07c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815b8a0011b20b005276762034b07c56">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a287887267f1d559fdec764f0027deb3a">reverse_iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向逆向 vector 首元素的逆向迭代器。 </p>

</div>
</div>
<a id="a1fa1bbc780f8c8fa352d758117e06aac" name="a1fa1bbc780f8c8fa352d758117e06aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa1bbc780f8c8fa352d758117e06aac">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#aea949cba6e24f77f55b2cf2861fe4602">const_reverse_iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向逆向 vector 首元素的逆向迭代器。 </p>

</div>
</div>
<a id="a8f91f2aa8c05813293cd6b3f35eb6b29" name="a8f91f2aa8c05813293cd6b3f35eb6b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f91f2aa8c05813293cd6b3f35eb6b29">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向逆向 vector 首元素的逆向迭代器。 </p>

</div>
</div>
<a id="a228506857923b5a136515dee5782f87e" name="a228506857923b5a136515dee5782f87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228506857923b5a136515dee5782f87e">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a287887267f1d559fdec764f0027deb3a">reverse_iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向逆向 vector 末元素后一元素的逆向迭代器。 </p>

</div>
</div>
<a id="aa021e9e9aa2678aa1365099300650ab4" name="aa021e9e9aa2678aa1365099300650ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa021e9e9aa2678aa1365099300650ab4">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#aea949cba6e24f77f55b2cf2861fe4602">const_reverse_iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向逆向 vector 末元素后一元素的逆向迭代器。 </p>

</div>
</div>
<a id="a64f681ade0b2495f3afa15d431ef8a70" name="a64f681ade0b2495f3afa15d431ef8a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f681ade0b2495f3afa15d431ef8a70">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#aea949cba6e24f77f55b2cf2861fe4602">const_reverse_iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回指向逆向 vector 末元素后一元素的逆向迭代器。 </p>

</div>
</div>
<a id="a8227f380a0a0011a8f094ae5d379b272" name="a8227f380a0a0011a8f094ae5d379b272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8227f380a0a0011a8f094ae5d379b272">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查容器是否无元素。 </p>

</div>
</div>
<a id="a1b825152cd32b169b614f3b0af796ba9" name="a1b825152cd32b169b614f3b0af796ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b825152cd32b169b614f3b0af796ba9">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回容器中的元素数。 </p>

</div>
</div>
<a id="a4680c7a84e7b87770a0d7e58b9334db0" name="a4680c7a84e7b87770a0d7e58b9334db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4680c7a84e7b87770a0d7e58b9334db0">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回根据系统或库实现限制的容器可保有的元素最大数量。 </p>

</div>
</div>
<a id="a8071acd8ca1e85cfdd508525ca8da229" name="a8071acd8ca1e85cfdd508525ca8da229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8071acd8ca1e85cfdd508525ca8da229">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>增加 vector 的容量到大于或等于 new_cap 的值。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>vector 的新容量。</td></tr>
  </table>
  </dd>
</dl>
<p>若 new_cap 大于当前的 <a class="el" href="clasststl_1_1vector.html#af5cca2b7e5ea48faf151969e8905f605" title="返回容器当前已为之分配空间的元素数。">capacity()</a>，则分配新存储，所有迭代器和所有到元素的引用都被非法化。</p>
<p >否则该方法不做任何事。 </p>

</div>
</div>
<a id="af5cca2b7e5ea48faf151969e8905f605" name="af5cca2b7e5ea48faf151969e8905f605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cca2b7e5ea48faf151969e8905f605">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回容器当前已为之分配空间的元素数。 </p>

</div>
</div>
<a id="a13d1dcfdcca5da25eada44d3202d0d03" name="a13d1dcfdcca5da25eada44d3202d0d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d1dcfdcca5da25eada44d3202d0d03">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57ec3706066d423a3204f57984085d43" name="a57ec3706066d423a3204f57984085d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ec3706066d423a3204f57984085d43">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>从容器擦除所有元素。此调用后 <a class="el" href="clasststl_1_1vector.html#a1b825152cd32b169b614f3b0af796ba9" title="返回容器中的元素数。">size()</a> 返回零。 </p>
<p >非法化任何指代所含元素的引用、指针或迭代器。 </p>

</div>
</div>
<a id="a880076e37b7af9a14308acb5f357451e" name="a880076e37b7af9a14308acb5f357451e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880076e37b7af9a14308acb5f357451e">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置 pos 前插入 value。 </p>

</div>
</div>
<a id="a345a81153e50982d054298baf68ac6e4" name="a345a81153e50982d054298baf68ac6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345a81153e50982d054298baf68ac6e4">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置 pos 前插入 value。 </p>

</div>
</div>
<a id="ac081a0406712bccdb1fa874c058ffe89" name="ac081a0406712bccdb1fa874c058ffe89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac081a0406712bccdb1fa874c058ffe89">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置 pos 前插入 value 的 count 个副本。 </p>

</div>
</div>
<a id="a1fe83ee74c8b5223555fdfbe5a618def" name="a1fe83ee74c8b5223555fdfbe5a618def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe83ee74c8b5223555fdfbe5a618def">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt , typename  = tstl::_RequireInputIter&lt;InputIt&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置 pos 前插入来自 [first, last) 的元素。 </p>

</div>
</div>
<a id="a67e68a5c4011d5327fef35eea00790d2" name="a67e68a5c4011d5327fef35eea00790d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e68a5c4011d5327fef35eea00790d2">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置 pos 前插入来自 initializer_list 的元素。 </p>

</div>
</div>
<a id="aa5d641ba2c2fc8c3f30a3d173bd0ddbe" name="aa5d641ba2c2fc8c3f30a3d173bd0ddbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d641ba2c2fc8c3f30a3d173bd0ddbe">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>直接于 pos 前插入元素到容器中。 </p>

</div>
</div>
<a id="af75166e1e7097dd9b9deb50050f20827" name="af75166e1e7097dd9b9deb50050f20827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75166e1e7097dd9b9deb50050f20827">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置 pos 移除元素。 </p>

</div>
</div>
<a id="aecf5429b875bfe6ecf979bd9a74d59da" name="aecf5429b875bfe6ecf979bd9a74d59da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf5429b875bfe6ecf979bd9a74d59da">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移除范围 [first, last) 中的元素。 </p>

</div>
</div>
<a id="a6a828879e126fe22cc8f138fea9540e9" name="a6a828879e126fe22cc8f138fea9540e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a828879e126fe22cc8f138fea9540e9">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初始化新元素为 value 的副本。 </p>

</div>
</div>
<a id="aacf85f1988d7a77c783d0b30cbae84c5" name="aacf85f1988d7a77c783d0b30cbae84c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf85f1988d7a77c783d0b30cbae84c5">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移动 value 进新元素。 </p>

</div>
</div>
<a id="a10559c38927a8ce08b0400bd5aed6581" name="a10559c38927a8ce08b0400bd5aed6581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10559c38927a8ce08b0400bd5aed6581">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>添加新元素到容器尾。 </p>

</div>
</div>
<a id="a1165177fc242f539d513b607b609ddc8" name="a1165177fc242f539d513b607b609ddc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1165177fc242f539d513b607b609ddc8">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移除容器的末元素。 </p>

</div>
</div>
<a id="acb21c0d431a88f8eceee1fdbbba50ad5" name="acb21c0d431a88f8eceee1fdbbba50ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb21c0d431a88f8eceee1fdbbba50ad5">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>重设容器大小以容纳 new_size 个元素，多余元素是默认元素。 </p>

</div>
</div>
<a id="a15ef1feeb87940e0547b8832bec81d3f" name="a15ef1feeb87940e0547b8832bec81d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ef1feeb87940e0547b8832bec81d3f">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>重设容器大小以容纳 new_size 个元素，多余元素是 value 的副本。 </p>

</div>
</div>
<a id="a8a34c8e7d71f511581d32fb1391167a9" name="a8a34c8e7d71f511581d32fb1391167a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a34c8e7d71f511581d32fb1391167a9">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>与 other 的交换。 </p>

</div>
</div>
<a id="a12f26049a37cce24591f019a93f400a5" name="a12f26049a37cce24591f019a93f400a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f26049a37cce24591f019a93f400a5">&#9670;&nbsp;</a></span>m_allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d0a2f4db9cfac750d1d2009a3a59e63" name="a8d0a2f4db9cfac750d1d2009a3a59e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0a2f4db9cfac750d1d2009a3a59e63">&#9670;&nbsp;</a></span>m_deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19476c2bcd9efcbc25ae1ecf639d7297" name="a19476c2bcd9efcbc25ae1ecf639d7297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19476c2bcd9efcbc25ae1ecf639d7297">&#9670;&nbsp;</a></span>m_destroy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3384484460fcbea0762cb3ddca7b9bb9" name="a3384484460fcbea0762cb3ddca7b9bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3384484460fcbea0762cb3ddca7b9bb9">&#9670;&nbsp;</a></span>m_destroy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99066507afd65b9b50c96deed3ecf943" name="a99066507afd65b9b50c96deed3ecf943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99066507afd65b9b50c96deed3ecf943">&#9670;&nbsp;</a></span>m_construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0620f0252b73c25593d0246e35367943" name="a0620f0252b73c25593d0246e35367943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0620f0252b73c25593d0246e35367943">&#9670;&nbsp;</a></span>m_create_storage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_create_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dbe70ee19228e9456af7307474a1160" name="a9dbe70ee19228e9456af7307474a1160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbe70ee19228e9456af7307474a1160">&#9670;&nbsp;</a></span>m_default_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_default_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a24539447fd133658cf48fd2e5ccb3dae" name="a24539447fd133658cf48fd2e5ccb3dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24539447fd133658cf48fd2e5ccb3dae">&#9670;&nbsp;</a></span>m_fill_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_fill_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa40ec5ee95d6015c38a32acad7c697d0" name="aa40ec5ee95d6015c38a32acad7c697d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40ec5ee95d6015c38a32acad7c697d0">&#9670;&nbsp;</a></span>m_uninitialized_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIter , typename ForwardIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_uninitialized_copy </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0faa93f46e3a3082857587352bfd534b" name="a0faa93f46e3a3082857587352bfd534b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0faa93f46e3a3082857587352bfd534b">&#9670;&nbsp;</a></span>m_insert_aux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_insert_aux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0dcd5fc00175dbbd5e8c779078f431e" name="ad0dcd5fc00175dbbd5e8c779078f431e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dcd5fc00175dbbd5e8c779078f431e">&#9670;&nbsp;</a></span>m_erase_at_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_erase_at_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac475cc0cf75725f387645987c36b0358" name="ac475cc0cf75725f387645987c36b0358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac475cc0cf75725f387645987c36b0358">&#9670;&nbsp;</a></span>m_insert_rval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_insert_rval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9afe6df486479af89da2b55e2a7398ae" name="a9afe6df486479af89da2b55e2a7398ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afe6df486479af89da2b55e2a7398ae">&#9670;&nbsp;</a></span>m_assign_aux() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_assign_aux </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstl_1_1input__iterator__tag.html">input_iterator_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3898fa64809482d2f2ba09869f35e39f" name="a3898fa64809482d2f2ba09869f35e39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3898fa64809482d2f2ba09869f35e39f">&#9670;&nbsp;</a></span>m_assign_aux() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_assign_aux </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstl_1_1forward__iterator__tag.html">forward_iterator_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b56e14f6bd7f19ce4af766d182114d6" name="a3b56e14f6bd7f19ce4af766d182114d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b56e14f6bd7f19ce4af766d182114d6">&#9670;&nbsp;</a></span>m_fill_assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_fill_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="clasststl_1_1vector.html#aa01279e0dee0bbf9d275b336625b1205">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cd527e540d73533bf6a99e8ab6a6126" name="a8cd527e540d73533bf6a99e8ab6a6126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd527e540d73533bf6a99e8ab6a6126">&#9670;&nbsp;</a></span>m_swap_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_swap_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6f99c20a18d052faecfa25e8e7245ad" name="ad6f99c20a18d052faecfa25e8e7245ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f99c20a18d052faecfa25e8e7245ad">&#9670;&nbsp;</a></span>m_insert_dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_insert_dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetstl.html#a32942c5bc5b0dc643cc1dee73a8a04dc">false_type</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39987132808ac64819bc12f38108b77d" name="a39987132808ac64819bc12f38108b77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39987132808ac64819bc12f38108b77d">&#9670;&nbsp;</a></span>m_range_insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_range_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstl_1_1forward__iterator__tag.html">tstl::forward_iterator_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a409e4499885e4a5e9878faf0e75bafc7" name="a409e4499885e4a5e9878faf0e75bafc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409e4499885e4a5e9878faf0e75bafc7">&#9670;&nbsp;</a></span>m_assign_dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_assign_dispatch </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetstl.html#a32942c5bc5b0dc643cc1dee73a8a04dc">false_type</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a726db10dc0b39a72e26071d15319b6a7" name="a726db10dc0b39a72e26071d15319b6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726db10dc0b39a72e26071d15319b6a7">&#9670;&nbsp;</a></span>m_fill_insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_fill_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5055d45250ebc1a3ed8f6343a4f673c5" name="a5055d45250ebc1a3ed8f6343a4f673c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5055d45250ebc1a3ed8f6343a4f673c5">&#9670;&nbsp;</a></span>m_move_assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_move_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2b177fbc03113e51f188bf8f7aa8445" name="aa2b177fbc03113e51f188bf8f7aa8445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b177fbc03113e51f188bf8f7aa8445">&#9670;&nbsp;</a></span>m_emplace_aux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_emplace_aux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a8b6df383347f89966f8361ccd94fa4dc">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5b145a396bd249b7fcd19336950393b" name="ac5b145a396bd249b7fcd19336950393b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b145a396bd249b7fcd19336950393b">&#9670;&nbsp;</a></span>m_realloc_insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_realloc_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15e18f95268803467ca3025ee4b0ec65" name="a15e18f95268803467ca3025ee4b0ec65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e18f95268803467ca3025ee4b0ec65">&#9670;&nbsp;</a></span>m_range_init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_range_init </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstl_1_1input__iterator__tag.html">tstl::input_iterator_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d19b608e591288a981368566a3c3359" name="a9d19b608e591288a981368566a3c3359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d19b608e591288a981368566a3c3359">&#9670;&nbsp;</a></span>m_check_len()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_check_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66ec6a37002a7382afc5129b2c8433b0" name="a66ec6a37002a7382afc5129b2c8433b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ec6a37002a7382afc5129b2c8433b0">&#9670;&nbsp;</a></span>m_erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dd3cba4e3d76479582c8ff137f80f05" name="a9dd3cba4e3d76479582c8ff137f80f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd3cba4e3d76479582c8ff137f80f05">&#9670;&nbsp;</a></span>m_erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#a2099f0a30068ff2976dfa9ab63a683f9">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63ac7cb6998cf7c226202beedda4b70d" name="a63ac7cb6998cf7c226202beedda4b70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ac7cb6998cf7c226202beedda4b70d">&#9670;&nbsp;</a></span>m_range_init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_range_init </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstl_1_1forward__iterator__tag.html">tstl::forward_iterator_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a590b5e3e9418d3827da36cb6bbd99a" name="a3a590b5e3e9418d3827da36cb6bbd99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a590b5e3e9418d3827da36cb6bbd99a">&#9670;&nbsp;</a></span>m_allocate_and_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_allocate_and_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a911aa142576b8b9187662855c4f05b4f" name="a911aa142576b8b9187662855c4f05b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911aa142576b8b9187662855c4f05b4f">&#9670;&nbsp;</a></span>m_default_append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_default_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85d3c3bbf24aca0b06ccffd314771a53" name="a85d3c3bbf24aca0b06ccffd314771a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d3c3bbf24aca0b06ccffd314771a53">&#9670;&nbsp;</a></span>m_range_check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_range_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clasststl_1_1vector.html#abed80c6c1ade9ac7baca57a633effd1c">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>越界检查，仅被 <a class="el" href="clasststl_1_1vector.html#a1c657d7d0241b45499c59b50c060901b" title="返回位于指定位置 pos 的元素的引用，有边界检查。 若 pos 不在容器范围内，则抛出 std::out_of_range 类型的异常。">at()</a> 使用。 </p>

</div>
</div>
<h2 class="groupheader">友元及相关函数文档</h2>
<a id="a33679563540934e4c3e487aa12a63424" name="a33679563540934e4c3e487aa12a63424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33679563540934e4c3e487aa12a63424">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="clasststl_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="clasststl_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="a5fe90893b20178bfb10fd95b60188566" name="a5fe90893b20178bfb10fd95b60188566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe90893b20178bfb10fd95b60188566">&#9670;&nbsp;</a></span>m_start</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_start = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeff94dd48bda4d0c530a5806866750d9" name="aeff94dd48bda4d0c530a5806866750d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff94dd48bda4d0c530a5806866750d9">&#9670;&nbsp;</a></span>m_finish</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_finish = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a657109d42ce87a09af5f007251330901" name="a657109d42ce87a09af5f007251330901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657109d42ce87a09af5f007251330901">&#9670;&nbsp;</a></span>m_end_of_storage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clasststl_1_1vector.html#a2b425422d70c1926bffddbff35291402">pointer</a> <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_end_of_storage = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a461fcfe25d20d79e086b31442ffb264b" name="a461fcfe25d20d79e086b31442ffb264b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461fcfe25d20d79e086b31442ffb264b">&#9670;&nbsp;</a></span>m_alloc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Allocator <a class="el" href="clasststl_1_1vector.html">tstl::vector</a>&lt; T, Allocator &gt;::m_alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li><a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2022年 二月 6日 星期日 06:14:12 , 为 Tiny STL使用 &#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
